# üå≥ Unique Binary Search Trees II

This JavaScript algorithm generates **all structurally unique binary search trees (BSTs)** that can be built using values from `1` to `n`.

---

## üß† Objective

Given an integer `n`, return **all unique BSTs** (not just the count) that can be built with values `1` through `n`.

Each BST must follow the **binary search tree rules**:

- Left subtree contains only values **less than** the root.
- Right subtree contains only values **greater than** the root.
- All trees must be **structurally unique** (different shape = different tree).

---

## üì• Input Example

```js
generateTrees(3);
```

## üì§ Output Example

The function returns an array of tree structures like:

```js
[
  {
    val: 1,
    left: null,
    right: { val: 2, left: null, right: { val: 3, left: null, right: null } },
  },
  {
    val: 1,
    left: null,
    right: { val: 3, left: { val: 2, left: null, right: null }, right: null },
  },
  {
    val: 2,
    left: { val: 1, left: null, right: null },
    right: { val: 3, left: null, right: null },
  },
  {
    val: 3,
    left: { val: 1, left: null, right: { val: 2, left: null, right: null } },
    right: null,
  },
  {
    val: 3,
    left: { val: 2, left: { val: 1, left: null, right: null }, right: null },
    right: null,
  },
];
```

## üå± Tree Visualizations for n = 3

```
Tree 1:       Tree 2:       Tree 3:       Tree 4:       Tree 5:

    1             1             2             3             3
     \             \           / \           /             /
      2             3         1   3         1             2
       \           /                           \         /
        3         2                             2       1
```

### ‚öôÔ∏è How It Works

This solution uses **pure recursion** with **manual memoization**  
(no JS methods like `.push()` or `Map`).

It defines a recursive function `buildTrees(start, end)` which:

- Picks every number `i` from `start` to `end` as a potential **root**.
- Recursively generates all **left subtrees** using values `< i`.
- Recursively generates all **right subtrees** using values `> i`.
- Combines **each left/right pair** with root `i` to form a new tree.
- Uses a `cache[start][end]` array to avoid recomputing subtrees.

---

### üß± Manual Memoization Strategy

- A 2D array `cache[start][end]` is used to store the result of each subproblem.
- Before computing `buildTrees(start, end)`, we check if it‚Äôs already in cache.
- Results are stored manually using `result[index] = value` (no `.push()`).

### üìä Time and Space Complexity

---

#### ‚è± Time Complexity: `O(n¬≤ √ó C‚Çô)`

- There are `O(n¬≤)` unique `(start, end)` subproblems.
- Each subproblem may generate up to `C‚Çô` unique trees.
- Building each tree takes up to `O(n)` time.

> **Catalan Number:**  
> \[
> C_n = \frac{1}{n + 1} \binom{2n}{n}
> \]

---

#### üíæ Space Complexity: `O(n √ó C‚Çô)`

- Stores `C‚Çô` unique trees.
- Each tree has up to `n` nodes.
- Stack space due to recursion is `O(n)`, but the total output dominates.
