# ğŸŒ³ Unique Binary Search Trees

This JavaScript algorithm calculates how many **structurally unique binary search trees (BSTs)** can be constructed using values from `1` to `n`.

---

## ğŸ§  Objective

Given an integer `n`, return the number of **distinct BSTs** that store values from `1` to `n`, where:

- Each BST must follow the **binary search tree property**:
  - Left subtree contains only nodes with values less than the root.
  - Right subtree contains only nodes with values greater than the root.
- BSTs must be **structurally unique** (different shapes count as different trees).

---

## ğŸ“¥ Input Example

````js
numTrees(3);
## ğŸ“¤ Expected Output
5

## ğŸŒ³ BST Visualizations for n = 3
These are the 5 unique BSTs that can be constructed using [1, 2, 3]:

1           1           2           3           3
 \           \         / \         /           /
  2           3       1   3       2           1
   \         /                       \           \
    3       2                         1           2

## âš™ï¸ How It Works

This algorithm uses **dynamic programming** to calculate the result.

We define an array `uniqueBSTs`, where:

- `uniqueBSTs[i]` holds the number of unique BSTs that can be formed using `i` nodes.

### ğŸ§± Base cases:

- `uniqueBSTs[0] = 1` â†’ an empty tree is a valid BST.
- `uniqueBSTs[1] = 1` â†’ only one way to form a tree with one node.

---

### ğŸ” For each total number of nodes `i`, we try each value `j` as the root:

- Nodes to the left of `j` â†’ `j - 1`
- Nodes to the right of `j` â†’ `i - j`

Then we calculate:

```js
combinations = uniqueBSTs[j - 1] * uniqueBSTs[i - j]
uniqueBSTs[i]```

## ğŸ“Š Time and Space Complexity

### â± Time Complexity: `O(nÂ²)`

- Outer loop runs from `2` to `n` â†’ `O(n)`
- Inner loop runs up to `i` â†’ `O(n)`
- **Total = O(nÂ²)**

---

### ğŸ’¾ Space Complexity: `O(n)`

- Uses one array of size `n + 1` to store intermediate results.
````
