# ğŸŒ² Symmetric Tree

This JavaScript algorithm checks whether a binary tree is a **mirror of itself** (symmetric around its center), using a recursive depth-first search â€” implemented **without any built-in JS methods**.

---

## ğŸ§  Objective

Given the root of a binary tree `root`, return `true` if it is symmetric, and `false` otherwise.

A tree is symmetric if the left subtree is a **mirror reflection** of the right subtree.

---

## âš™ï¸ How It Works

1. Define a helper function `isMirror(a, b)` that checks if two subtrees are mirrors:
   - If both nodes are `null` â†’ symmetric at this branch
   - If one is `null` and the other is not â†’ not symmetric
   - If values differ â†’ not symmetric
2. Recursively compare:
   - Left child of `a` with right child of `b`
   - Right child of `a` with left child of `b`
3. The whole tree is symmetric if `isMirror(root.left, root.right)` returns true.

---

## ğŸ“¥ Input Example

```js
root = [1, 2, 2, 3, 4, 4, 3];
```

## ğŸ“¤ Expected Output

true

## ğŸ” Execution Step-by-Step

**Example 1:**

`root = [1,2,2,3,4,4,3]`

- Compare 2 (left) with 2 (right) â†’ âœ… ok
- Compare 3 (left-left) with 3 (right-right) â†’ âœ… ok
- Compare 4 (left-right) with 4 (right-left) â†’ âœ… ok  
  **âœ… Symmetric â†’ true**

---

**Example 2:**

`root = [1,2,2,null,3,null,3]`

- Compare 2 (left) with 2 (right) â†’ âœ… ok
- Compare null (left-left) with 3 (right-right) â†’ âŒ mismatch â†’ false

---

**Example 3:**

`root = [1]`

Single node is always symmetric â†’ **true**

## ğŸ“Š Time and Space Complexity

**Time:** `O(n)`  
Each node is visited once in its pair comparison.

**Space:** `O(h)`  
Where `h` is the height of the tree (recursion stack).

- **Best case** (balanced): `O(log n)`
- **Worst case** (skewed): `O(n)`
