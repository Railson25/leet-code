# ğŸ”¢ `generateParenthesis` (Generate Well-Formed Parentheses)

This JavaScript algorithm generates **all possible combinations** of well-formed parentheses given `n` pairs.  
It uses **backtracking** to explore valid sequences while avoiding invalid ones during construction.

---

## ğŸ§  Objective

Given an integer `n`, return **all valid combinations** of `n` pairs of parentheses.

A sequence is valid if:

- It contains exactly `n` `'('` and `n` `')'`.
- At no point in the sequence do closing parentheses `')'` exceed opening parentheses `'('`.

---

## ğŸ“ Example Rules

For `n = 3`, valid outputs include:

((()))
(()())
(())()
()(())
()()()

Invalid examples:

- `())(()` â†’ closes too early
- `((()` â†’ not enough closing parentheses

---

## ğŸ› ï¸ How the Algorithm Works

```txt
1. Create a buffer (array) of size 2n to store characters during construction.
2. Start recursion with pos = 0, open = 0, close = 0.
3. At each position:
   a. If open < n â†’ place '(' and recurse.
   b. If close < open â†’ place ')' and recurse.
4. When pos === 2n â†’ convert buffer to string and save it.
5. After recursion ends, return all saved strings.
```

## ğŸ“¥ Input Example

const n = 3;

## ğŸ“¤ Expected Output

["((()))","(()())","(())()","()(())","()()()"]

## ğŸ” Step-by-Step Breakdown for n = 2

1. Start: pos=0, open=0, close=0 â†’ add `'('`
2. pos=1, open=1, close=0 â†’ add `'('`
3. pos=2, open=2, close=0 â†’ can't add `'('`, add `')'`
4. pos=3, open=2, close=1 â†’ add `')'`
5. **Found:** `(())`
6. Backtrack to pos=1, open=1, close=0 â†’ add `')'`
7. pos=2, open=1, close=1 â†’ add `'('`
8. pos=3, open=2, close=1 â†’ add `')'`
9. **Found:** `()()`

**Output:**

```js
["(())", "()()"];
```

## ğŸ“Š Time and Space Complexity

| Type  | Complexity |
| ----- | ---------- |
| Time  | O(k Â· n)   |
| Space | O(k Â· n)   |

Where:

- `n` = input number of pairs
- `k` = total number of valid combinations (n-th Catalan number)

Auxiliary space (without output) is `O(n)` for recursion stack + buffer.
