# 🔢 `countAndSay` (Count and Say Sequence)

This JavaScript algorithm generates the `n`-th term of the **Count and Say** sequence.  
Each term in the sequence is a verbal description of the previous term, using run-length encoding logic.

---

## 🧠 Objective

Given a positive integer `n`, return the `n`-th element of the **count-and-say** sequence.

Each term describes the previous term by counting **consecutive repeating digits**.

---

## 🔁 Sequence Pattern

| Term | Value    | Description                     |
| ---- | -------- | ------------------------------- |
| 1    | "1"      | Start with "1"                  |
| 2    | "11"     | one 1 → "11"                    |
| 3    | "21"     | two 1s → "21"                   |
| 4    | "1211"   | one 2, one 1 → "1211"           |
| 5    | "111221" | one 1, one 2, two 1s → "111221" |

---

## 🛠️ How the Algorithm Works

```txt
1. Initialize the first term as the string "1"
2. Repeat the following process n - 1 times:
   a. Initialize an empty result string (next)
   b. Loop through the current string:
      - Count how many times the same digit repeats in sequence
      - Append "count + digit" to the next string
   c. Update the current string with the newly constructed result
3. Return the current string after all iterations
```

## 📥 Input Example

const n = 4;

## 📤 Expected Output

"1211"

## 🔎 Step-by-Step Breakdown for n = 4

Term 1: "1"
Term 2: "11" → one 1
Term 3: "21" → two 1s
Term 4: "1211" → one 2, one 1

## 📊 Time and Space Complexity

| Type  | Complexity |
| ----- | ---------- |
| Time  | O(2ⁿ)      |
| Space | O(2ⁿ)      |

The length of each term in the sequence can **double** in the worst case.

Each term is generated by scanning the previous one, so as `n` increases, both time and space grow exponentially.
